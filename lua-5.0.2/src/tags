$T	Makefile	/^$T:	$(OBJS)$/
Arith	lvm.c	/^static int Arith (lua_State *L, StkId ra,$/
CREATE_ABC	lopcodes.h	/^#define CREATE_ABC(o,a,b,c)	(cast(Instruction, o) /
CREATE_ABx	lopcodes.h	/^#define CREATE_ABx(o,a,bc)	(cast(Instruction, o) \\/
DumpBlock	ldump.c	/^static void DumpBlock(const void* b, size_t size, /
DumpByte	ldump.c	/^static void DumpByte(int y, DumpState* D)$/
DumpCode	ldump.c	/^static void DumpCode(const Proto* f, DumpState* D)/
DumpConstants	ldump.c	/^static void DumpConstants(const Proto* f, DumpStat/
DumpFunction	ldump.c	/^static void DumpFunction(const Proto* f, const TSt/
DumpHeader	ldump.c	/^static void DumpHeader(DumpState* D)$/
DumpInt	ldump.c	/^static void DumpInt(int x, DumpState* D)$/
DumpLines	ldump.c	/^static void DumpLines(const Proto* f, DumpState* D/
DumpLiteral	ldump.c	/^#define DumpLiteral(s,D)	DumpBlock("" s,(sizeof(s)/
DumpLocals	ldump.c	/^static void DumpLocals(const Proto* f, DumpState* /
DumpNumber	ldump.c	/^static void DumpNumber(lua_Number x, DumpState* D)/
DumpSize	ldump.c	/^static void DumpSize(size_t x, DumpState* D)$/
DumpString	ldump.c	/^static void DumpString(TString* s, DumpState* D)$/
DumpUpvalues	ldump.c	/^static void DumpUpvalues(const Proto* f, DumpState/
DumpVector	ldump.c	/^#define DumpVector(b,n,size,D)	DumpBlock(b,(n)*(si/
EQ	ltests.c	/^#define EQ(s1)	(strcmp(s1, inst) == 0)$/
G	lstate.h	/^#define G(L)	(L->l_G)$/
GCscale	lapi.c	/^#define GCscale(x)		(cast(int, GCscalel(x)))$/
GCscalel	lapi.c	/^#define GCscalel(x)		((x)>>10)$/
GCunscale	lapi.c	/^#define GCunscale(x)		(cast(lu_mem, x)<<10)$/
GETARG_A	lopcodes.h	/^#define GETARG_A(i)	(cast(int, (i)>>POS_A))$/
GETARG_B	lopcodes.h	/^#define GETARG_B(i)	(cast(int, ((i)>>POS_B) & MASK/
GETARG_Bx	lopcodes.h	/^#define GETARG_Bx(i)	(cast(int, ((i)>>POS_Bx) & MA/
GETARG_C	lopcodes.h	/^#define GETARG_C(i)	(cast(int, ((i)>>POS_C) & MASK/
GETARG_sBx	lopcodes.h	/^#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)$/
GET_OPCODE	lopcodes.h	/^#define GET_OPCODE(i)	(cast(OpCode, (i)&MASK1(SIZE/
IntPoint	llimits.h	/^#define IntPoint(p)  ((lu_hash)(p))$/
KBx	lvm.c	/^#define KBx(i)	(k+GETARG_Bx(i))$/
LoadBlock	lundump.c	/^static void LoadBlock (LoadState* S, void* b, size/
LoadChunk	lundump.c	/^static Proto* LoadChunk (LoadState* S)$/
LoadCode	lundump.c	/^static void LoadCode (LoadState* S, Proto* f)$/
LoadConstants	lundump.c	/^static void LoadConstants (LoadState* S, Proto* f)/
LoadFunction	lundump.c	/^static Proto* LoadFunction (LoadState* S, TString*/
LoadHeader	lundump.c	/^static void LoadHeader (LoadState* S)$/
LoadInt	lundump.c	/^static int LoadInt (LoadState* S)$/
LoadLines	lundump.c	/^static void LoadLines (LoadState* S, Proto* f)$/
LoadLocals	lundump.c	/^static void LoadLocals (LoadState* S, Proto* f)$/
LoadNumber	lundump.c	/^static lua_Number LoadNumber (LoadState* S)$/
LoadSignature	lundump.c	/^static void LoadSignature (LoadState* S)$/
LoadSize	lundump.c	/^static size_t LoadSize (LoadState* S)$/
LoadString	lundump.c	/^static TString* LoadString (LoadState* S)$/
LoadUpvalues	lundump.c	/^static void LoadUpvalues (LoadState* S, Proto* f)$/
LoadVector	lundump.c	/^static void LoadVector (LoadState* S, void* b, int/
MASK0	lopcodes.h	/^#define MASK0(n,p)	(~MASK1(n,p))$/
MASK1	lopcodes.h	/^#define MASK1(n,p)	((~((~(Instruction)0)<<n))<<p)$/
Mltests	ltests.c	/^int main (int argc, char *argv[]) {$/
RA	lvm.c	/^#define RA(i)	(base+GETARG_A(i))$/
RB	lvm.c	/^#define RB(i)	(base+GETARG_B(i))$/
RC	lvm.c	/^#define RC(i)	(base+GETARG_C(i))$/
RKB	lvm.c	/^#define RKB(i)	((GETARG_B(i) < MAXSTACK) ? RB(i) :/
RKC	lvm.c	/^#define RKC(i)	((GETARG_C(i) < MAXSTACK) ? RC(i) :/
SETARG_A	lopcodes.h	/^#define SETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,PO/
SETARG_B	lopcodes.h	/^#define SETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,PO/
SETARG_Bx	lopcodes.h	/^#define SETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,/
SETARG_C	lopcodes.h	/^#define SETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,PO/
SETARG_sBx	lopcodes.h	/^#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigne/
SETOBJ2S_YP	lvm.c	/^#define SETOBJ2S_YP(src, val) do { \\$/
SET_OPCODE	lopcodes.h	/^#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP/
TESTSIZE	lundump.c	/^#define TESTSIZE(s,w)	TestSize(S,s,w)$/
TestSize	lundump.c	/^static void TestSize (LoadState* S, int s, const c/
UNUSED	llimits.h	/^#define UNUSED(x)	((void)(x))	\/* to avoid warnings/
V	lundump.c	/^#define V(v)		v\/16,v%16$/
XRA	lvm.c	/^#define XRA(i)	(L->base+GETARG_A(i))$/
YP	lvm.c	/^#define YP(res) do { \\$/
__pow	testmeta.lua	/^    function __pow(x, y)$/
a	testmeta.lua	/^    function a.func(a, b)$/
addinfo	ldebug.c	/^static void addinfo (lua_State *L, const char *msg/
addk	lcode.c	/^static int addk (FuncState *fs, TObject *k, TObjec/
adjust_assign	lparser.c	/^static void adjust_assign (LexState *ls, int nvars/
adjust_varargs	ldo.c	/^static void adjust_varargs (lua_State *L, int nfix/
adjustlocalvars	lparser.c	/^static void adjustlocalvars (LexState *ls, int nva/
all	Makefile	/^all:	$T$/
api_check	lapi.c	/^#define api_check(L, o)		\/*{ assert(o); }*\/$/
api_checknelems	lapi.c	/^#define api_checknelems(L, n)	api_check(L, (n) <= /
api_incr_top	lapi.c	/^#define api_incr_top(L)   {api_check(L, L->top < L/
arrayindex	ltable.c	/^static int arrayindex (const TObject *key) {$/
assignment	lparser.c	/^static void assignment (LexState *ls, struct LHS_a/
aux_upvalue	lapi.c	/^static const char *aux_upvalue (lua_State *L, int /
auxgetinfo	ldebug.c	/^static int auxgetinfo (lua_State *L, const char *w/
b	testmeta.lua	/^    function b.__index(a, b)$/
binopistest	lcode.h	/^#define binopistest(op)	((op) >= OPR_NE)$/
block	lparser.c	/^static void block (LexState *ls) {$/
block_follow	lparser.c	/^static int block_follow (int token) {$/
blockhead	ltests.c	/^#define blockhead(b)	(cast(char *, b) - HEADER)$/
body	lparser.c	/^static void body (LexState *ls, expdesc *e, int ne/
breakstat	lparser.c	/^static void breakstat (LexState *ls) {$/
buildop	ltests.c	/^static char *buildop (Proto *p, int pc, char *buff/
bvalue	lobject.h	/^#define bvalue(o)	check_exp(ttisboolean(o), (o)->v/
callTM	lvm.c	/^static int callTM (lua_State *L, const TObject *f,/
callTMres	lvm.c	/^static int callTMres (lua_State *L, const TObject /
call_binTM	lvm.c	/^static int call_binTM (lua_State *L, const TObject/
call_orderTM	lvm.c	/^static int call_orderTM (lua_State *L, const TObje/
callallgcTM	lstate.c	/^static void callallgcTM (lua_State *L, void *ud) {/
callrethooks	ldo.c	/^static StkId callrethooks (lua_State *L, StkId fir/
cast	llimits.h	/^#define cast(t, exp)	((t)(exp))$/
char2int	lzio.h	/^#define char2int(c)	cast(int, cast(unsigned char, /
check	ldebug.c	/^#define check(x)		if (!(x)) return 0;$/
checkRK	ldebug.c	/^static int checkRK (const Proto *pt, int r) {$/
checkSizes	lgc.c	/^static void checkSizes (lua_State *L, size_t deadm/
check_condition	lparser.c	/^#define check_condition(ls,c,msg)	{ if (!(c)) luaX/
check_conflict	lparser.c	/^static void check_conflict (LexState *ls, struct L/
check_exp	llimits.h	/^#define check_exp(c,e)	(e)$/
check_match	lparser.c	/^static void check_match (LexState *ls, int what, i/
checkblock	ltests.c	/^static void *checkblock (void *block, size_t size)/
checkblocksize	ltests.c	/^#define checkblocksize(b, size) (size == (*cast(si/
checkbuffer	llex.c	/^#define checkbuffer(LS, len)	\\$/
checkconsistency	lobject.h	/^#define checkconsistency(obj) \\$/
checkjump	ldebug.c	/^#define checkjump(pt,pc)	check(0 <= pc && pc < pt-/
checkname	lparser.c	/^static void checkname(LexState *ls, expdesc *e) {$/
checkopenop	ldebug.c	/^static int checkopenop (const Proto *pt, int pc) {/
checkreg	ldebug.c	/^#define checkreg(pt,reg)	check((reg) < (pt)->maxst/
checkstacksizes	lgc.c	/^static void checkstacksizes (lua_State *L, StkId m/
chgnvalue	lobject.h	/^#define chgnvalue(obj,x) \\$/
chunk	lparser.c	/^static void chunk (LexState *ls) {$/
ci_func	lstate.h	/^#define ci_func(ci)	(clvalue((ci)->base - 1))$/
clean	Makefile	/^clean:$/
cleartablekeys	lgc.c	/^static void cleartablekeys (GCObject *l) {$/
cleartablevalues	lgc.c	/^static void cleartablevalues (GCObject *l) {$/
close_func	lparser.c	/^static void close_func (LexState *ls) {$/
close_state	lstate.c	/^static void close_state (lua_State *L) {$/
closelistfield	lparser.c	/^static void closelistfield (FuncState *fs, struct /
closestate	ltests.c	/^static int closestate (lua_State *L) {$/
clvalue	lobject.h	/^#define clvalue(o)	check_exp(ttisfunction(o), &(o)/
co	Makefile	/^co:$/
code_label	lcode.c	/^static int code_label (FuncState *fs, int A, int b/
code_params	lparser.c	/^static void code_params (LexState *ls, int nparams/
codebinop	lcode.c	/^static void codebinop (FuncState *fs, expdesc *res/
codenot	lcode.c	/^static void codenot (FuncState *fs, expdesc *e) {$/
codestring	lparser.c	/^static void codestring (LexState *ls, expdesc *e, /
computesizes	ltable.c	/^static void computesizes  (int nums[], int ntotal,/
cond	lparser.c	/^static void cond (LexState *ls, expdesc *v) {$/
condhardstacktests	ldo.h	/^#define condhardstacktests(x)	{ \/* empty *\/ }$/
condmarkobject	lgc.c	/^#define condmarkobject(st,o,c) { checkconsistency(/
constructor	lparser.c	/^static void constructor (LexState *ls, expdesc *t)/
coresume	ltests.c	/^static int coresume (lua_State *L) {$/
correctstack	ldo.c	/^static void correctstack (lua_State *L, TObject *o/
create_local	lparser.c	/^static void create_local (LexState *ls, const char/
currentline	ldebug.c	/^static int currentline (CallInfo *ci) {$/
currentpc	ldebug.c	/^static int currentpc (CallInfo *ci) {$/
d2s	ltests.c	/^static int d2s (lua_State *L) {$/
debug_realloc	ltests.c	/^void *debug_realloc (void *block, size_t oldsize, /
default_panic	lstate.c	/^static int default_panic (lua_State *L) {$/
defaultmeta	lstate.h	/^#define defaultmeta(L)	(&G(L)->_defaultmeta)$/
discharge2anyreg	lcode.c	/^static void discharge2anyreg (FuncState *fs, expde/
discharge2reg	lcode.c	/^static void discharge2reg (FuncState *fs, expdesc /
do1gcTM	lgc.c	/^static void do1gcTM (lua_State *L, Udata *udata) {/
dojump	lvm.c	/^#define dojump(pc, i)	((pc) += (i))$/
doonnewstack	ltests.c	/^static int doonnewstack (lua_State *L) {$/
doremote	ltests.c	/^static int doremote (lua_State *L) {$/
enterblock	lparser.c	/^static void enterblock (FuncState *fs, BlockCnt *b/
enterlevel	lparser.c	/^#define enterlevel(ls)	if (++(ls)->nestlevel > LUA/
equalobj	lvm.h	/^#define equalobj(L,o1,o2) \\$/
error_expected	lparser.c	/^static void error_expected (LexState *ls, int toke/
exp1	lparser.c	/^static int exp1 (LexState *ls) {$/
explist1	lparser.c	/^static int explist1 (LexState *ls, expdesc *v) {$/
expr	lparser.c	/^static void expr (LexState *ls, expdesc *v) {$/
exprstat	lparser.c	/^static void exprstat (LexState *ls) {$/
ezgetc	lundump.c	/^static int ezgetc (LoadState* S)$/
ezread	lundump.c	/^static void ezread (LoadState* S, void* b, int n)$/
f_Ccall	lapi.c	/^static void f_Ccall (lua_State *L, void *ud) {$/
f_call	lapi.c	/^static void f_call (lua_State *L, void *ud) {$/
f_luaopen	lstate.c	/^static void f_luaopen (lua_State *L, void *ud) {$/
f_parser	ldo.c	/^static void f_parser (lua_State *L, void *ud) {$/
fasttm	ltm.h	/^#define fasttm(l,et,e)	gfasttm(G(l), et, e)$/
fb2int	lobject.h	/^#define fb2int(x)	(((x) & 7) << ((x) >> 3))$/
fillmem	ltests.c	/^#define fillmem(mem,size)	memset(mem, -MARK, size)/
fim	ltests.c	/^static void fim (void) {$/
forbody	lparser.c	/^static void forbody (LexState *ls, int base, int l/
forlist	lparser.c	/^static void forlist (LexState *ls, TString *indexn/
fornum	lparser.c	/^static void fornum (LexState *ls, TString *varname/
forstat	lparser.c	/^static void forstat (LexState *ls, int line) {$/
freeblock	ltests.c	/^static void freeblock (void *block, size_t size) {/
freeexp	lcode.c	/^static void freeexp (FuncState *fs, expdesc *e) {$/
freeobj	lgc.c	/^static void freeobj (lua_State *L, GCObject *o) {$/
freereg	lcode.c	/^static void freereg (FuncState *fs, int reg) {$/
freestack	lstate.c	/^static void freestack (lua_State *L, lua_State *L1/
freestate	lstate.c	/^static void freestate (lua_State *L, lua_State *L1/
func_at	ltests.c	/^#define func_at(L,k)	(L->ci->base+(k) - 1)$/
funcargs	lparser.c	/^static void funcargs (LexState *ls, expdesc *f) {$/
funcinfo	ldebug.c	/^static void funcinfo (lua_Debug *ar, StkId func) {/
funcname	lparser.c	/^static int funcname (LexState *ls, expdesc *v) {$/
funcstat	lparser.c	/^static void funcstat (LexState *ls, int line) {$/
gcotocl	lstate.h	/^#define gcotocl(o)	check_exp((o)->gch.tt == LUA_TF/
gcotoh	lstate.h	/^#define gcotoh(o)	check_exp((o)->gch.tt == LUA_TTA/
gcotop	lstate.h	/^#define gcotop(o)	check_exp((o)->gch.tt == LUA_TPR/
gcototh	lstate.h	/^#define gcototh(o)	check_exp((o)->gch.tt == LUA_TT/
gcotots	lstate.h	/^#define gcotots(o)	check_exp((o)->gch.tt == LUA_TS/
gcotou	lstate.h	/^#define gcotou(o)	check_exp((o)->gch.tt == LUA_TUS/
gcotouv	lstate.h	/^#define gcotouv(o)	check_exp((o)->gch.tt == LUA_TU/
gcvalue	lobject.h	/^#define gcvalue(o)	check_exp(iscollectable(o), (o)/
getOpMode	lopcodes.h	/^#define getOpMode(m)            (cast(enum OpMode,/
get_compTM	lvm.c	/^static const TObject *get_compTM (lua_State *L, Ta/
get_limits	ltests.c	/^static int get_limits (lua_State *L) {$/
getbinopr	lparser.c	/^static BinOpr getbinopr (int op) {$/
getcode	lcode.h	/^#define getcode(fs,e)	((fs)->f->code[(e)->info])$/
getfuncname	ldebug.c	/^static const char *getfuncname (CallInfo *ci, cons/
getjumpcontrol	lcode.c	/^static Instruction *getjumpcontrol (FuncState *fs,/
getline	ldebug.h	/^#define getline(f,pc)	(((f)->lineinfo) ? (f)->line/
getlocvar	lparser.c	/^#define getlocvar(fs, i)	((fs)->f->locvars[(fs)->a/
getluaproto	ldebug.c	/^static Proto *getluaproto (CallInfo *ci) {$/
getname_aux	ltests.c	/^static const char *getname_aux (char *buff, const /
getnum_aux	ltests.c	/^static int getnum_aux (lua_State *L, const char **/
getobjname	ldebug.c	/^static const char *getobjname (CallInfo *ci, int s/
getref	ltests.c	/^static int getref (lua_State *L) {$/
getstr	lobject.h	/^#define getstr(ts)	cast(const char *, (ts) + 1)$/
getunopr	lparser.c	/^static UnOpr getunopr (int op) {$/
gfasttm	ltm.h	/^#define gfasttm(g,et,e) \\$/
gkey	ltable.h	/^#define gkey(n)		(&(n)->i_key)$/
gnode	ltable.h	/^#define gnode(t,i)	(&(t)->node[i])$/
gt	lstate.h	/^#define gt(L)	(&L->_gt)$/
gval	ltable.h	/^#define gval(n)		(&(n)->i_val)$/
hash_query	ltests.c	/^static int hash_query (lua_State *L) {$/
hashboolean	ltable.c	/^#define hashboolean(t,p)        hashpow2(t, p)$/
hashmod	ltable.c	/^#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t/
hashnum	ltable.c	/^static Node *hashnum (const Table *t, lua_Number n/
hashpointer	ltable.c	/^#define hashpointer(t,p)	hashmod(t, IntPoint(p))$/
hashpow2	ltable.c	/^#define hashpow2(t,n)      (gnode(t, lmod((n), siz/
hashstr	ltable.c	/^#define hashstr(t,str)  hashpow2(t, (str)->tsv.has/
hasjumps	lcode.c	/^#define hasjumps(e)	((e)->t != (e)->f)$/
hvalue	lobject.h	/^#define hvalue(o)	check_exp(ttistable(o), &(o)->va/
ifstat	lparser.c	/^static void ifstat (LexState *ls, int line) {$/
inclinenumber	llex.c	/^static void inclinenumber (LexState *LS) {$/
incr_top	ldo.h	/^#define incr_top(L) {luaD_checkstack(L,1); L->top+/
indexupvalue	lparser.c	/^static int indexupvalue (FuncState *fs, TString *n/
info_tailcall	ldebug.c	/^static void info_tailcall (lua_State *L, lua_Debug/
init_exp	lparser.c	/^static void init_exp (expdesc *e, expkind k, int i/
int2fb_aux	ltests.c	/^static int int2fb_aux (lua_State *L) {$/
invertjump	lcode.c	/^static void invertjump (FuncState *fs, expdesc *e)/
isLfunction	lobject.h	/^#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION /
isLua	ldebug.c	/^#define isLua(ci)	(!((ci)->state & CI_C))$/
iscfunction	lobject.h	/^#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION /
iscollectable	lobject.h	/^#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)/
isfinalized	lgc.c	/^#define isfinalized(u)		(!testbit((u)->uv.marked, /
isinstack	ldebug.c	/^static int isinstack (CallInfo *ci, const TObject /
ismarked	lgc.c	/^#define ismarked(x)	((x)->gch.marked & ((1<<4)|1))/
jumponcond	lcode.c	/^static int jumponcond (FuncState *fs, expdesc *e, /
klean	Makefile	/^klean:	clean$/
kname	ldebug.c	/^static const char *kname (Proto *p, int c) {$/
l_free	lmem.c	/^#define l_free(b,os)	free(b)$/
l_isfalse	lobject.h	/^#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o/
l_panic	ltests.c	/^static int l_panic (lua_State *L) {$/
l_realloc	lmem.c	/^#define l_realloc(b,os,s)	realloc(b,s)$/
lastlistfield	lparser.c	/^static void lastlistfield (FuncState *fs, struct C/
leaveblock	lparser.c	/^static void leaveblock (FuncState *fs) {$/
leavelevel	lparser.c	/^#define leavelevel(ls)	((ls)->nestlevel--)$/
listcode	ltests.c	/^static int listcode (lua_State *L) {$/
listfield	lparser.c	/^static void listfield (LexState *ls, struct ConsCo/
listk	ltests.c	/^static int listk (lua_State *L) {$/
listlocals	ltests.c	/^static int listlocals (lua_State *L) {$/
lmod	lobject.h	/^#define lmod(s,size) \\$/
loadlib	ltests.c	/^static int loadlib (lua_State *L) {$/
localfunc	lparser.c	/^static void localfunc (LexState *ls) {$/
localstat	lparser.c	/^static void localstat (LexState *ls) {$/
log2_aux	ltests.c	/^static int log2_aux (lua_State *L) {$/
lookahead	lparser.c	/^static void lookahead (LexState *ls) {$/
luaA_index	lapi.c	/^static TObject *luaA_index (lua_State *L, int idx)/
luaA_indexAcceptable	lapi.c	/^static TObject *luaA_indexAcceptable (lua_State *L/
luaA_pushobject	lapi.c	/^void luaA_pushobject (lua_State *L, const TObject /
luaB_opentests	ltests.c	/^int luaB_opentests (lua_State *L) {$/
luaC_callGCTM	lgc.c	/^void luaC_callGCTM (lua_State *L) {$/
luaC_checkGC	lgc.h	/^#define luaC_checkGC(L) { lua_assert(!(L->ci->stat/
luaC_collectgarbage	lgc.c	/^void luaC_collectgarbage (lua_State *L) {$/
luaC_link	lgc.c	/^void luaC_link (lua_State *L, GCObject *o, lu_byte/
luaC_separateudata	lgc.c	/^size_t luaC_separateudata (lua_State *L) {$/
luaC_sweep	lgc.c	/^void luaC_sweep (lua_State *L, int all) {$/
luaD_call	ldo.c	/^void luaD_call (lua_State *L, StkId func, int nRes/
luaD_call_yp	ldo.c	/^int luaD_call_yp (lua_State *L, StkId func, int nR/
luaD_callhook	ldo.c	/^void luaD_callhook (lua_State *L, int event, int l/
luaD_checkstack	ldo.h	/^#define luaD_checkstack(L,n)	\\$/
luaD_growCI	ldo.c	/^static void luaD_growCI (lua_State *L) {$/
luaD_growstack	ldo.c	/^void luaD_growstack (lua_State *L, int n) {$/
luaD_pcall	ldo.c	/^int luaD_pcall (lua_State *L, Pfunc func, void *u,/
luaD_poscall	ldo.c	/^void luaD_poscall (lua_State *L, int wanted, StkId/
luaD_precall	ldo.c	/^StkId luaD_precall (lua_State *L, StkId func) {$/
luaD_protectedparser	ldo.c	/^int luaD_protectedparser (lua_State *L, ZIO *z, in/
luaD_rawrunprotected	ldo.c	/^int luaD_rawrunprotected (lua_State *L, Pfunc f, v/
luaD_reallocCI	ldo.c	/^void luaD_reallocCI (lua_State *L, int newsize) {$/
luaD_reallocstack	ldo.c	/^void luaD_reallocstack (lua_State *L, int newsize)/
luaD_throw	ldo.c	/^void luaD_throw (lua_State *L, int errcode) {$/
luaE_freethread	lstate.c	/^void luaE_freethread (lua_State *L, lua_State *L1)/
luaE_newthread	lstate.c	/^lua_State *luaE_newthread (lua_State *L) {$/
luaF_close	lfunc.c	/^void luaF_close (lua_State *L, StkId level) {$/
luaF_findupval	lfunc.c	/^UpVal *luaF_findupval (lua_State *L, StkId level) /
luaF_freeclosure	lfunc.c	/^void luaF_freeclosure (lua_State *L, Closure *c) {/
luaF_freeproto	lfunc.c	/^void luaF_freeproto (lua_State *L, Proto *f) {$/
luaF_getlocalname	lfunc.c	/^const char *luaF_getlocalname (const Proto *f, int/
luaF_newCclosure	lfunc.c	/^Closure *luaF_newCclosure (lua_State *L, int nelem/
luaF_newLclosure	lfunc.c	/^Closure *luaF_newLclosure (lua_State *L, int nelem/
luaF_newproto	lfunc.c	/^Proto *luaF_newproto (lua_State *L) {$/
luaG_aritherror	ldebug.c	/^void luaG_aritherror (lua_State *L, const TObject /
luaG_checkcode	ldebug.c	/^int luaG_checkcode (const Proto *pt) {$/
luaG_concaterror	ldebug.c	/^void luaG_concaterror (lua_State *L, StkId p1, Stk/
luaG_errormsg	ldebug.c	/^void luaG_errormsg (lua_State *L) {$/
luaG_inithooks	ldebug.c	/^void luaG_inithooks (lua_State *L) {$/
luaG_ordererror	ldebug.c	/^int luaG_ordererror (lua_State *L, const TObject */
luaG_runerror	ldebug.c	/^void luaG_runerror (lua_State *L, const char *fmt,/
luaG_symbexec	ldebug.c	/^static Instruction luaG_symbexec (const Proto *pt,/
luaG_typeerror	ldebug.c	/^void luaG_typeerror (lua_State *L, const TObject */
luaH_free	ltable.c	/^void luaH_free (lua_State *L, Table *t) {$/
luaH_get	ltable.c	/^const TObject *luaH_get (Table *t, const TObject */
luaH_getany	ltable.c	/^static const TObject *luaH_getany (Table *t, const/
luaH_getnum	ltable.c	/^const TObject *luaH_getnum (Table *t, int key) {$/
luaH_getstr	ltable.c	/^const TObject *luaH_getstr (Table *t, TString *key/
luaH_index	ltable.c	/^static int luaH_index (lua_State *L, Table *t, Stk/
luaH_mainposition	ltable.c	/^Node *luaH_mainposition (const Table *t, const TOb/
luaH_new	ltable.c	/^Table *luaH_new (lua_State *L, int narray, int lnh/
luaH_next	ltable.c	/^int luaH_next (lua_State *L, Table *t, StkId key) /
luaH_remove	ltable.c	/^void luaH_remove (Table *t, Node *e) {$/
luaH_set	ltable.c	/^TObject *luaH_set (lua_State *L, Table *t, const T/
luaH_setnum	ltable.c	/^TObject *luaH_setnum (lua_State *L, Table *t, int /
luaI_printcode	ltests.c	/^void luaI_printcode (Proto *pt, int size) {$/
luaI_registerlocalvar	lparser.c	/^static int luaI_registerlocalvar (LexState *ls, TS/
luaK_checkstack	lcode.c	/^void luaK_checkstack (FuncState *fs, int n) {$/
luaK_code	lcode.c	/^int luaK_code (FuncState *fs, Instruction i, int l/
luaK_codeABC	lcode.c	/^int luaK_codeABC (FuncState *fs, OpCode o, int a, /
luaK_codeABx	lcode.c	/^int luaK_codeABx (FuncState *fs, OpCode o, int a, /
luaK_codeAsBx	lcode.h	/^#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,/
luaK_concat	lcode.c	/^void luaK_concat (FuncState *fs, int *l1, int l2) /
luaK_condjump	lcode.c	/^static int luaK_condjump (FuncState *fs, OpCode op/
luaK_dischargejpc	lcode.c	/^static void luaK_dischargejpc (FuncState *fs) {$/
luaK_dischargevars	lcode.c	/^void luaK_dischargevars (FuncState *fs, expdesc *e/
luaK_exp2RK	lcode.c	/^int luaK_exp2RK (FuncState *fs, expdesc *e) {$/
luaK_exp2anyreg	lcode.c	/^int luaK_exp2anyreg (FuncState *fs, expdesc *e) {$/
luaK_exp2nextreg	lcode.c	/^void luaK_exp2nextreg (FuncState *fs, expdesc *e) /
luaK_exp2reg	lcode.c	/^static void luaK_exp2reg (FuncState *fs, expdesc */
luaK_exp2val	lcode.c	/^void luaK_exp2val (FuncState *fs, expdesc *e) {$/
luaK_fixjump	lcode.c	/^static void luaK_fixjump (FuncState *fs, int pc, i/
luaK_fixline	lcode.c	/^void luaK_fixline (FuncState *fs, int line) {$/
luaK_getjump	lcode.c	/^static int luaK_getjump (FuncState *fs, int pc) {$/
luaK_getlabel	lcode.c	/^int luaK_getlabel (FuncState *fs) {$/
luaK_goiffalse	lcode.c	/^void luaK_goiffalse (FuncState *fs, expdesc *e) {$/
luaK_goiftrue	lcode.c	/^void luaK_goiftrue (FuncState *fs, expdesc *e) {$/
luaK_indexed	lcode.c	/^void luaK_indexed (FuncState *fs, expdesc *t, expd/
luaK_infix	lcode.c	/^void luaK_infix (FuncState *fs, BinOpr op, expdesc/
luaK_jump	lcode.c	/^int luaK_jump (FuncState *fs) {$/
luaK_nil	lcode.c	/^void luaK_nil (FuncState *fs, int from, int n) {$/
luaK_numberK	lcode.c	/^int luaK_numberK (FuncState *fs, lua_Number r) {$/
luaK_patchlist	lcode.c	/^void luaK_patchlist (FuncState *fs, int list, int /
luaK_patchlistaux	lcode.c	/^static void luaK_patchlistaux (FuncState *fs, int /
luaK_patchtohere	lcode.c	/^void luaK_patchtohere (FuncState *fs, int list) {$/
luaK_posfix	lcode.c	/^void luaK_posfix (FuncState *fs, BinOpr op, expdes/
luaK_prefix	lcode.c	/^void luaK_prefix (FuncState *fs, UnOpr op, expdesc/
luaK_reserveregs	lcode.c	/^void luaK_reserveregs (FuncState *fs, int n) {$/
luaK_self	lcode.c	/^void luaK_self (FuncState *fs, expdesc *e, expdesc/
luaK_setcallreturns	lcode.c	/^void luaK_setcallreturns (FuncState *fs, expdesc */
luaK_storevar	lcode.c	/^void luaK_storevar (FuncState *fs, expdesc *var, e/
luaK_stringK	lcode.c	/^int luaK_stringK (FuncState *fs, TString *s) {$/
luaM_free	lmem.h	/^#define luaM_free(L, b, s)	luaM_realloc(L, (b), (s/
luaM_freearray	lmem.h	/^#define luaM_freearray(L, b, n, t)	luaM_realloc(L,/
luaM_freelem	lmem.h	/^#define luaM_freelem(L, b)	luaM_realloc(L, (b), si/
luaM_growaux	lmem.c	/^void *luaM_growaux (lua_State *L, void *block, int/
luaM_growvector	lmem.h	/^#define luaM_growvector(L,v,nelems,size,t,limit,e)/
luaM_malloc	lmem.h	/^#define luaM_malloc(L, t)	luaM_realloc(L, NULL, 0,/
luaM_new	lmem.h	/^#define luaM_new(L, t)          cast(t *, luaM_mal/
luaM_newvector	lmem.h	/^#define luaM_newvector(L, n,t)  cast(t *, luaM_mal/
luaM_realloc	lmem.c	/^void *luaM_realloc (lua_State *L, void *block, lu_/
luaM_reallocvector	lmem.h	/^#define luaM_reallocvector(L, v,oldn,n,t) \\$/
luaO_chunkid	lobject.c	/^void luaO_chunkid (char *out, const char *source, /
luaO_int2fb	lobject.c	/^int luaO_int2fb (unsigned int x) {$/
luaO_log2	lobject.c	/^int luaO_log2 (unsigned int x) {$/
luaO_pushfstring	lobject.c	/^const char *luaO_pushfstring (lua_State *L, const /
luaO_pushvfstring	lobject.c	/^const char *luaO_pushvfstring (lua_State *L, const/
luaO_rawequalObj	lobject.c	/^int luaO_rawequalObj (const TObject *t1, const TOb/
luaO_str2d	lobject.c	/^int luaO_str2d (const char *s, lua_Number *result)/
luaS_fix	lstring.h	/^#define luaS_fix(s)	((s)->tsv.marked |= (1<<4))$/
luaS_freeall	lstring.c	/^void luaS_freeall (lua_State *L) {$/
luaS_new	lstring.h	/^#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(/
luaS_newliteral	lstring.h	/^#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" /
luaS_newlstr	lstring.c	/^TString *luaS_newlstr (lua_State *L, const char *s/
luaS_newudata	lstring.c	/^Udata *luaS_newudata (lua_State *L, size_t s) {$/
luaS_resize	lstring.c	/^void luaS_resize (lua_State *L, int newsize) {$/
luaT_gettm	ltm.c	/^const TObject *luaT_gettm (Table *events, TMS even/
luaT_gettmbyobj	ltm.c	/^const TObject *luaT_gettmbyobj (lua_State *L, cons/
luaT_init	ltm.c	/^void luaT_init (lua_State *L) {$/
luaU_dump	ldump.c	/^void luaU_dump (lua_State* L, const Proto* Main, l/
luaU_endianness	lundump.c	/^int luaU_endianness (void)$/
luaU_undump	lundump.c	/^Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer*/
luaV_concat	lvm.c	/^int luaV_concat (lua_State *L, int total, int last/
luaV_equalval	lvm.c	/^int luaV_equalval (lua_State *L, const TObject *t1/
luaV_execute	lvm.c	/^StkId luaV_execute (lua_State *L) {$/
luaV_getnotable	lvm.c	/^static const TObject *luaV_getnotable (lua_State */
luaV_gettable	lvm.c	/^const TObject *luaV_gettable (lua_State *L, const /
luaV_index	lvm.c	/^static const TObject *luaV_index (lua_State *L, co/
luaV_lessequal	lvm.c	/^static int luaV_lessequal (lua_State *L, const TOb/
luaV_lessthan	lvm.c	/^int luaV_lessthan (lua_State *L, const TObject *l,/
luaV_return	lvm.c	/^StkId luaV_return (lua_State *L, CallInfo *ci, Stk/
luaV_settable	lvm.c	/^int luaV_settable (lua_State *L, const TObject *t,/
luaV_strcmp	lvm.c	/^static int luaV_strcmp (const TString *ls, const T/
luaV_tonumber	lvm.c	/^const TObject *luaV_tonumber (const TObject *obj, /
luaV_tostring	lvm.c	/^int luaV_tostring (lua_State *L, StkId obj) {$/
luaX_checklimit	llex.c	/^void luaX_checklimit (LexState *ls, int val, int l/
luaX_error	llex.c	/^static void luaX_error (LexState *ls, const char */
luaX_errorline	llex.c	/^void luaX_errorline (LexState *ls, const char *s, /
luaX_init	llex.c	/^void luaX_init (lua_State *L) {$/
luaX_lex	llex.c	/^int luaX_lex (LexState *LS, SemInfo *seminfo) {$/
luaX_lexerror	llex.c	/^static void luaX_lexerror (LexState *ls, const cha/
luaX_setinput	llex.c	/^void luaX_setinput (lua_State *L, LexState *LS, ZI/
luaX_syntaxerror	llex.c	/^void luaX_syntaxerror (LexState *ls, const char *m/
luaX_token2str	llex.c	/^const char *luaX_token2str (LexState *ls, int toke/
luaY_field	lparser.c	/^static void luaY_field (LexState *ls, expdesc *v) /
luaY_index	lparser.c	/^static void luaY_index (LexState *ls, expdesc *v) /
luaY_parser	lparser.c	/^Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer /
luaZ_buffer	lzio.h	/^#define luaZ_buffer(buff)	((buff)->buffer)$/
luaZ_fill	lzio.c	/^int luaZ_fill (ZIO *z) {$/
luaZ_freebuffer	lzio.h	/^#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer/
luaZ_init	lzio.c	/^void luaZ_init (ZIO *z, lua_Chunkreader reader, vo/
luaZ_initbuffer	lzio.h	/^#define luaZ_initbuffer(L, buff) ((buff)->buffer =/
luaZ_lookahead	lzio.c	/^int luaZ_lookahead (ZIO *z) {$/
luaZ_openspace	lzio.c	/^char *luaZ_openspace (lua_State *L, Mbuffer *buff,/
luaZ_read	lzio.c	/^size_t luaZ_read (ZIO *z, void *b, size_t n) {$/
luaZ_resizebuffer	lzio.h	/^#define luaZ_resizebuffer(L, buff, size) \\$/
luaZ_sizebuffer	lzio.h	/^#define luaZ_sizebuffer(buff)	((buff)->buffsize)$/
lua_assert	llimits.h	/^#define lua_assert(c)		\/* empty *\/$/
lua_atpanic	lapi.c	/^LUA_API lua_CFunction lua_atpanic (lua_State *L, l/
lua_call	lapi.c	/^LUA_API void lua_call (lua_State *L, int nargs, in/
lua_call_yp	lapi.c	/^LUA_API int lua_call_yp (lua_State *L, int nargs, /
lua_checkstack	lapi.c	/^LUA_API int lua_checkstack (lua_State *L, int size/
lua_close	lstate.c	/^LUA_API void lua_close (lua_State *L) {$/
lua_concat	lapi.c	/^LUA_API void lua_concat (lua_State *L, int n) {$/
lua_cpcall	lapi.c	/^LUA_API int lua_cpcall (lua_State *L, lua_CFunctio/
lua_dump	lapi.c	/^LUA_API int lua_dump (lua_State *L, lua_Chunkwrite/
lua_equal	lapi.c	/^LUA_API int lua_equal (lua_State *L, int index1, i/
lua_error	lapi.c	/^LUA_API int lua_error (lua_State *L) {$/
lua_get_frame_state	lapi.c	/^LUA_API void *lua_get_frame_state (lua_State *L) {/
lua_getfenv	lapi.c	/^LUA_API void lua_getfenv (lua_State *L, int idx) {/
lua_getgccount	lapi.c	/^LUA_API int lua_getgccount (lua_State *L) {$/
lua_getgcthreshold	lapi.c	/^LUA_API int lua_getgcthreshold (lua_State *L) {$/
lua_gethook	ldebug.c	/^LUA_API lua_Hook lua_gethook (lua_State *L) {$/
lua_gethookcount	ldebug.c	/^LUA_API int lua_gethookcount (lua_State *L) {$/
lua_gethookmask	ldebug.c	/^LUA_API int lua_gethookmask (lua_State *L) {$/
lua_getinfo	ldebug.c	/^LUA_API int lua_getinfo (lua_State *L, const char /
lua_getlocal	ldebug.c	/^LUA_API const char *lua_getlocal (lua_State *L, co/
lua_getmetatable	lapi.c	/^LUA_API int lua_getmetatable (lua_State *L, int ob/
lua_getstack	ldebug.c	/^LUA_API int lua_getstack (lua_State *L, int level,/
lua_gettable	lapi.c	/^LUA_API void lua_gettable (lua_State *L, int idx) /
lua_gettop	lapi.c	/^LUA_API int lua_gettop (lua_State *L) {$/
lua_getupvalue	lapi.c	/^LUA_API const char *lua_getupvalue (lua_State *L, /
lua_insert	lapi.c	/^LUA_API void lua_insert (lua_State *L, int idx) {$/
lua_iscfunction	lapi.c	/^LUA_API int lua_iscfunction (lua_State *L, int idx/
lua_isnumber	lapi.c	/^LUA_API int lua_isnumber (lua_State *L, int idx) {/
lua_isstring	lapi.c	/^LUA_API int lua_isstring (lua_State *L, int idx) {/
lua_isuserdata	lapi.c	/^LUA_API int lua_isuserdata (lua_State *L, int idx)/
lua_lessthan	lapi.c	/^LUA_API int lua_lessthan (lua_State *L, int index1/
lua_load	lapi.c	/^LUA_API int lua_load (lua_State *L, lua_Chunkreade/
lua_lock	lstate.h	/^#define lua_lock(L)	((void) 0)$/
lua_newtable	lapi.c	/^LUA_API void lua_newtable (lua_State *L) {$/
lua_newthread	lapi.c	/^LUA_API lua_State *lua_newthread (lua_State *L) {$/
lua_newuserdata	lapi.c	/^LUA_API void *lua_newuserdata (lua_State *L, size_/
lua_next	lapi.c	/^LUA_API int lua_next (lua_State *L, int idx) {$/
lua_number2int	ltable.c	/^#define lua_number2int(i,n)	((i)=(int)(n))$/
lua_number2str	lvm.c	/^#define lua_number2str(s,n)     sprintf((s), LUA_N/
lua_open	lstate.c	/^LUA_API lua_State *lua_open (void) {$/
lua_pcall	lapi.c	/^LUA_API int lua_pcall (lua_State *L, int nargs, in/
lua_pushboolean	lapi.c	/^LUA_API void lua_pushboolean (lua_State *L, int b)/
lua_pushcclosure	lapi.c	/^LUA_API void lua_pushcclosure (lua_State *L, lua_C/
lua_pushfstring	lapi.c	/^LUA_API const char *lua_pushfstring (lua_State *L,/
lua_pushintegral	ltests.c	/^#define lua_pushintegral(L,i)	lua_pushnumber(L, ca/
lua_pushlightuserdata	lapi.c	/^LUA_API void lua_pushlightuserdata (lua_State *L, /
lua_pushlstring	lapi.c	/^LUA_API void lua_pushlstring (lua_State *L, const /
lua_pushnil	lapi.c	/^LUA_API void lua_pushnil (lua_State *L) {$/
lua_pushnumber	lapi.c	/^LUA_API void lua_pushnumber (lua_State *L, lua_Num/
lua_pushstring	lapi.c	/^LUA_API void lua_pushstring (lua_State *L, const c/
lua_pushupvalues	lapi.c	/^LUA_API int lua_pushupvalues (lua_State *L) {$/
lua_pushvalue	lapi.c	/^LUA_API void lua_pushvalue (lua_State *L, int idx)/
lua_pushvfstring	lapi.c	/^LUA_API const char *lua_pushvfstring (lua_State *L/
lua_rawequal	lapi.c	/^LUA_API int lua_rawequal (lua_State *L, int index1/
lua_rawget	lapi.c	/^LUA_API void lua_rawget (lua_State *L, int idx) {$/
lua_rawgeti	lapi.c	/^LUA_API void lua_rawgeti (lua_State *L, int idx, i/
lua_rawset	lapi.c	/^LUA_API void lua_rawset (lua_State *L, int idx) {$/
lua_rawseti	lapi.c	/^LUA_API void lua_rawseti (lua_State *L, int idx, i/
lua_remove	lapi.c	/^LUA_API void lua_remove (lua_State *L, int idx) {$/
lua_replace	lapi.c	/^LUA_API void lua_replace (lua_State *L, int idx) {/
lua_resume	ldo.c	/^LUA_API int lua_resume (lua_State *L, int nargs) {/
lua_setcycles	lapi.c	/^LUA_API void lua_setcycles(lua_State *L, int cycle/
lua_setfenv	lapi.c	/^LUA_API int lua_setfenv (lua_State *L, int idx) {$/
lua_setgcthreshold	lapi.c	/^LUA_API void lua_setgcthreshold (lua_State *L, int/
lua_sethook	ldebug.c	/^LUA_API int lua_sethook (lua_State *L, lua_Hook fu/
lua_setlocal	ldebug.c	/^LUA_API const char *lua_setlocal (lua_State *L, co/
lua_setmetatable	lapi.c	/^LUA_API int lua_setmetatable (lua_State *L, int ob/
lua_settable	lapi.c	/^LUA_API void lua_settable (lua_State *L, int idx) /
lua_settable_yp	lapi.c	/^LUA_API int lua_settable_yp (lua_State *L, int idx/
lua_settop	lapi.c	/^LUA_API void lua_settop (lua_State *L, int idx) {$/
lua_setupvalue	lapi.c	/^LUA_API const char *lua_setupvalue (lua_State *L, /
lua_str2number	lobject.c	/^#define lua_str2number(s,p)     strtod((s), (p))$/
lua_strlen	lapi.c	/^LUA_API size_t lua_strlen (lua_State *L, int idx) /
lua_toboolean	lapi.c	/^LUA_API int lua_toboolean (lua_State *L, int idx) /
lua_tocfunction	lapi.c	/^LUA_API lua_CFunction lua_tocfunction (lua_State */
lua_tonumber	lapi.c	/^LUA_API lua_Number lua_tonumber (lua_State *L, int/
lua_topointer	lapi.c	/^LUA_API const void *lua_topointer (lua_State *L, i/
lua_tostring	lapi.c	/^LUA_API const char *lua_tostring (lua_State *L, in/
lua_tothread	lapi.c	/^LUA_API lua_State *lua_tothread (lua_State *L, int/
lua_touserdata	lapi.c	/^LUA_API void *lua_touserdata (lua_State *L, int id/
lua_type	lapi.c	/^LUA_API int lua_type (lua_State *L, int idx) {$/
lua_typename	lapi.c	/^LUA_API const char *lua_typename (lua_State *L, in/
lua_unlock	lstate.h	/^#define lua_unlock(L)	((void) 0)$/
lua_userstateopen	lstate.h	/^#define lua_userstateopen(l)$/
lua_version	lapi.c	/^LUA_API const char *lua_version (void) {$/
lua_xmove	lapi.c	/^LUA_API void lua_xmove (lua_State *from, lua_State/
lua_yield	ldo.c	/^LUA_API int lua_yield (lua_State *L, int nresults)/
mallocstate	lstate.c	/^static lua_State *mallocstate (lua_State *L) {$/
mark	lgc.c	/^static size_t mark (lua_State *L) {$/
markfinalized	lgc.c	/^#define markfinalized(u)	resetbit((u)->uv.marked, /
markobject	lgc.c	/^#define markobject(st,o) { checkconsistency(o); \\$/
markroot	lgc.c	/^static void markroot (GCState *st, lua_State *L) {/
marktmu	lgc.c	/^static void marktmu (GCState *st) {$/
markupval	lparser.c	/^static void markupval (FuncState *fs, int level) {/
markvalue	lgc.c	/^#define markvalue(st,t) { if (!ismarked(valtogco(t/
mem_query	ltests.c	/^static int mem_query (lua_State *L) {$/
metatable	ltests.c	/^static int metatable (lua_State *L) {$/
need_value	lcode.c	/^static int need_value (FuncState *fs, int list, in/
negindex	lapi.c	/^static TObject *negindex (lua_State *L, int idx) {/
new_localvar	lparser.c	/^static void new_localvar (LexState *ls, TString *n/
new_localvarstr	lparser.c	/^static void new_localvarstr (LexState *ls, const c/
newkey	ltable.c	/^static TObject *newkey (lua_State *L, Table *t, co/
newlstr	lstring.c	/^static TString *newlstr (lua_State *L, const char /
newstate	ltests.c	/^static int newstate (lua_State *L) {$/
newuserdata	ltests.c	/^static int newuserdata (lua_State *L) {$/
next	llex.c	/^#define next(LS) (LS->current = zgetc(LS->z))$/
ngcotouv	lstate.h	/^#define ngcotouv(o) \\$/
nil_constant	lcode.c	/^static int nil_constant (FuncState *fs) {$/
numuse	ltable.c	/^static void numuse (const Table *t, int *narray, i/
nvalue	lobject.h	/^#define nvalue(o)	check_exp(ttisnumber(o), (o)->va/
open_func	lparser.c	/^static void open_func (LexState *ls, FuncState *fs/
opmode	lopcodes.c	/^#define opmode(t,b,bk,ck,sa,k,m) (((t)<<OpModeT) |/
parlist	lparser.c	/^static void parlist (LexState *ls) {$/
patchtestreg	lcode.c	/^static void patchtestreg (Instruction *i, int reg)/
pcRel	ldebug.h	/^#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) /
precheck	ldebug.c	/^static int precheck (const Proto *pt) {$/
prefixexp	lparser.c	/^static void prefixexp (LexState *ls, expdesc *v) {/
preinit_state	lstate.c	/^static void preinit_state (lua_State *L) {$/
primaryexp	lparser.c	/^static void primaryexp (LexState *ls, expdesc *v) /
propagatemarks	lgc.c	/^static void propagatemarks (GCState *st) {$/
pushclosure	lparser.c	/^static void pushclosure (LexState *ls, FuncState */
pushstr	lobject.c	/^static void pushstr (lua_State *L, const char *str/
pushuserdata	ltests.c	/^static int pushuserdata (lua_State *L) {$/
pvalue	lobject.h	/^#define pvalue(o)	check_exp(ttislightuserdata(o), /
read_long_string	llex.c	/^static void read_long_string (LexState *LS, SemInf/
read_numeral	llex.c	/^static void read_numeral (LexState *LS, int comma,/
read_string	llex.c	/^static void read_string (LexState *LS, int del, Se/
readname	llex.c	/^static size_t readname (LexState *LS) {$/
reallymarkobject	lgc.c	/^static void reallymarkobject (GCState *st, GCObjec/
recfield	lparser.c	/^static void recfield (LexState *ls, struct ConsCon/
registry	lstate.h	/^#define registry(L)	(&G(L)->_registry)$/
rehash	ltable.c	/^static void rehash (lua_State *L, Table *t) {$/
removekey	lgc.c	/^static void removekey (Node *n) {$/
removevars	lparser.c	/^static void removevars (LexState *ls, int tolevel)/
repeatstat	lparser.c	/^static void repeatstat (LexState *ls, int line) {$/
resetbit	lgc.c	/^#define resetbit(x,b)	((x) &= cast(lu_byte, ~(1<<(/
resethookcount	ldebug.h	/^#define resethookcount(L)	(L->hookcount = L->baseh/
resize	ltable.c	/^static void resize (lua_State *L, Table *t, int na/
restore_stack_limit	ldo.c	/^static void restore_stack_limit (lua_State *L) {$/
restoreci	ldo.h	/^#define restoreci(L,n)		((CallInfo *)((char *)L->b/
restorestack	ldo.h	/^#define restorestack(L,n)	((TObject *)((char *)L->/
resume	ldo.c	/^static void resume (lua_State *L, void *ud) {$/
resume_error	ldo.c	/^static int resume_error (lua_State *L, const char /
retstat	lparser.c	/^static void retstat (LexState *ls) {$/
runtime_check	lvm.c	/^#define runtime_check(L, c)	{ if (!(c)) return 0; /
s2d	ltests.c	/^static int s2d (lua_State *L) {$/
save	llex.c	/^#define save(LS, c, l) \\$/
save_and_next	llex.c	/^#define save_and_next(LS, l)  (save(LS, LS->curren/
saveci	ldo.h	/^#define saveci(L,p)		((char *)(p) - (char *)L->bas/
savestack	ldo.h	/^#define savestack(L,p)		((char *)(p) - (char *)L->/
searchvar	lparser.c	/^static int searchvar (FuncState *fs, TString *n) {/
setarrayvector	ltable.c	/^static void setarrayvector (lua_State *L, Table *t/
setbit	lgc.c	/^#define setbit(x,b)	((x) |= (1<<(b)))$/
setbvalue	lobject.h	/^#define setbvalue(obj,x) \\$/
setclvalue	lobject.h	/^#define setclvalue(obj,x) \\$/
seterrorobj	ldo.c	/^static void seterrorobj (lua_State *L, int errcode/
sethvalue	lobject.h	/^#define sethvalue(obj,x) \\$/
setnameval	ltests.c	/^static void setnameval (lua_State *L, const char */
setnilvalue	lobject.h	/^#define setnilvalue(obj) ((obj)->tt=LUA_TNIL)$/
setnodevector	ltable.c	/^static void setnodevector (lua_State *L, Table *t,/
setnvalue	lobject.h	/^#define setnvalue(obj,x) \\$/
setobj	lobject.h	/^#define setobj(obj1,obj2) \\$/
setpvalue	lobject.h	/^#define setpvalue(obj,x) \\$/
setsize	ltests.c	/^#define setsize(newblock, size)	(*cast(size_t *, n/
setsvalue	lobject.h	/^#define setsvalue(obj,x) \\$/
setthvalue	lobject.h	/^#define setthvalue(obj,x) \\$/
setttype	lobject.h	/^#define setttype(obj, tt) (ttype(obj) = (tt))$/
setuvalue	lobject.h	/^#define setuvalue(obj,x) \\$/
setyhook	ltests.c	/^static int setyhook (lua_State *L) {$/
simpleexp	lparser.c	/^static void simpleexp (LexState *ls, expdesc *v) {/
singlevar	lparser.c	/^static TString *singlevar (LexState *ls, expdesc */
singlevaraux	lparser.c	/^static void singlevaraux (FuncState *fs, TString */
sizeCclosure	lfunc.c	/^#define sizeCclosure(n)	(cast(int, sizeof(CClosure/
sizeLclosure	lfunc.c	/^#define sizeLclosure(n)	(cast(int, sizeof(LClosure/
sizenode	lobject.h	/^#define sizenode(t)	(twoto((t)->lsizenode))$/
sizestring	lstring.h	/^#define sizestring(l)	(cast(lu_mem, sizeof(union T/
sizeudata	lstring.h	/^#define sizeudata(l)	(cast(lu_mem, sizeof(union Ud/
skip	ltests.c	/^static void skip (const char **pc) {$/
stack_init	lstate.c	/^static void stack_init (lua_State *L1, lua_State */
stacklevel	ltests.c	/^static int stacklevel (lua_State *L) {$/
statement	lparser.c	/^static int statement (LexState *ls) {$/
str_checkname	lparser.c	/^static TString *str_checkname (LexState *ls) {$/
string_query	ltests.c	/^static int string_query (lua_State *L) {$/
stringmark	lgc.c	/^#define stringmark(s)	setbit((s)->tsv.marked, 0)$/
subexpr	lparser.c	/^static BinOpr subexpr (LexState *ls, expdesc *v, i/
svalue	lobject.h	/^#define svalue(o)       getstr(tsvalue(o))$/
sweeplist	lgc.c	/^static int sweeplist (lua_State *L, GCObject **p, /
sweepstrings	lgc.c	/^static void sweepstrings (lua_State *L, int all) {/
table_query	ltests.c	/^static int table_query (lua_State *L) {$/
testC	ltests.c	/^static int testC (lua_State *L) {$/
testOpMode	lopcodes.h	/^#define testOpMode(m, b)        (luaP_opmodes[m] &/
test_OP_ADD	testmeta.lua	/^function test_OP_ADD()$/
test_OP_CONCAT	testmeta.lua	/^function test_OP_CONCAT()$/
test_OP_DIV	testmeta.lua	/^function test_OP_DIV()$/
test_OP_EQ	testmeta.lua	/^function test_OP_EQ()$/
test_OP_GETGLOBAL	testmeta.lua	/^function test_OP_GETGLOBAL()$/
test_OP_GETTABLE	testmeta.lua	/^function test_OP_GETTABLE()$/
test_OP_GETTABLE_tail	testmeta.lua	/^function test_OP_GETTABLE_tail()$/
test_OP_LE	testmeta.lua	/^function test_OP_LE()$/
test_OP_LT	testmeta.lua	/^function test_OP_LT()$/
test_OP_MUL	testmeta.lua	/^function test_OP_MUL()$/
test_OP_POW	testmeta.lua	/^function test_OP_POW()$/
test_OP_POW_global	testmeta.lua	/^function test_OP_POW_global()$/
test_OP_SELF	testmeta.lua	/^function test_OP_SELF()$/
test_OP_SETGLOBAL	testmeta.lua	/^function test_OP_SETGLOBAL()$/
test_OP_SETTABLE	testmeta.lua	/^function test_OP_SETTABLE()$/
test_OP_SUB	testmeta.lua	/^function test_OP_SUB()$/
test_OP_TFORLOOP	testmeta.lua	/^function test_OP_TFORLOOP()$/
test_OP_UNM	testmeta.lua	/^function test_OP_UNM()$/
test_do	ltests.c	/^static int test_do (lua_State *L) {$/
test_dofile	testmeta.lua	/^function test_dofile()$/
test_plain_coro	testmeta.lua	/^function test_plain_coro()$/
test_print	testmeta.lua	/^function test_print()$/
test_string_gsub	testmeta.lua	/^function test_string_gsub()$/
test_table_foreach	testmeta.lua	/^function test_table_foreach()$/
test_table_foreachi	testmeta.lua	/^function test_table_foreachi()$/
test_then_block	lparser.c	/^static void test_then_block (LexState *ls, expdesc/
test_tostring	testmeta.lua	/^function test_tostring()$/
testbit	lgc.c	/^#define testbit(x,b)	((x) & (1<<(b)))$/
testnext	lparser.c	/^static int testnext (LexState *ls, int c) {$/
thvalue	lobject.h	/^#define thvalue(o)	check_exp(ttisthread(o), &(o)->/
tonumber	lvm.h	/^#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || /
toobig	ltable.c	/^#define toobig(x)	((((x)-1) >> MAXBITS) != 0)$/
tostring	lvm.h	/^#define tostring(L,o) ((ttype(o) == LUA_TSTRING) |/
traceexec	lvm.c	/^static void traceexec (lua_State *L) {$/
traverseclosure	lgc.c	/^static void traverseclosure (GCState *st, Closure /
traverseproto	lgc.c	/^static void traverseproto (GCState *st, Proto *f) /
traversestack	lgc.c	/^static void traversestack (GCState *st, lua_State /
traversetable	lgc.c	/^static void traversetable (GCState *st, Table *h) /
travglobals	ldebug.c	/^static const char *travglobals (lua_State *L, cons/
tref	ltests.c	/^static int tref (lua_State *L) {$/
tryfuncTM	ldo.c	/^static StkId tryfuncTM (lua_State *L, StkId func) /
tsvalue	lobject.h	/^#define tsvalue(o)	check_exp(ttisstring(o), &(o)->/
ttisboolean	lobject.h	/^#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)$/
ttisfunction	lobject.h	/^#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION/
ttislightuserdata	lobject.h	/^#define ttislightuserdata(o)	(ttype(o) == LUA_TLIG/
ttisnil	lobject.h	/^#define ttisnil(o)	(ttype(o) == LUA_TNIL)$/
ttisnumber	lobject.h	/^#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)$/
ttisstring	lobject.h	/^#define ttisstring(o)	(ttype(o) == LUA_TSTRING)$/
ttistable	lobject.h	/^#define ttistable(o)	(ttype(o) == LUA_TTABLE)$/
ttisthread	lobject.h	/^#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)$/
ttisuserdata	lobject.h	/^#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA/
ttype	lobject.h	/^#define ttype(o)	((o)->tt)$/
twoto	lobject.h	/^#define twoto(x)	(1<<(x))$/
udataval	ltests.c	/^static int udataval (lua_State *L) {$/
unexpectedEOZ	lundump.c	/^static void unexpectedEOZ (LoadState* S)$/
unmark	lgc.c	/^#define unmark(x)	resetbit((x)->gch.marked, 0)$/
unref	ltests.c	/^static int unref (lua_State *L) {$/
upvalue	ltests.c	/^static int upvalue (lua_State *L) {$/
uvalue	lobject.h	/^#define uvalue(o)	check_exp(ttisuserdata(o), &(o)-/
valismarked	lgc.c	/^static int valismarked (const TObject *o) {$/
valtogco	lstate.h	/^#define valtogco(v)	(cast(GCObject *, (v)))$/
whilestat	lparser.c	/^static void whilestat (LexState *ls, int line) {$/
yieldf	ltests.c	/^static void yieldf (lua_State *L, lua_Debug *ar) {/
zgetc	lzio.h	/^#define zgetc(z)  (((z)->n--)>0 ?  char2int(*(z)->/
zname	lzio.h	/^#define zname(z)	((z)->name)$/
